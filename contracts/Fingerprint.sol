// SPDX-License-Identifier: MIT

pragma solidity ^0.8.16;

import { PRBMathSD59x18  } from "@prb/math/contracts/PRBMathSD59x18.sol";

/**
 * @title Fingerprint
 * @author nftchance
 * @notice Fingerprint is an extension that enables the token-level gating of access without 
 *         the concern of gas costs or rampant token re-use. Traditionally, much of the Ethereum 
 *         ecosystem has relied on the use of a single token to represent access to a particular
 *         while then resolving that credential to the user, instead of the token: which was the
 *         actual key, the user merely turned the key in the lock. 
 * @dev Fingerprint solves this problem by creating a unique fingerprint for each token, which is then
 *      used to gate access to the resource. This fingerprint is a 32 byte hash, which is
 *      generated by hashing the token's ID and the user's address. This fingerprint is
 *      then used to gate access to the resource, and is not re-usable until the fingerprint decay 
 *      reached zero. The stored fingerprint is also not accessible on-chain, and is only generated when the user 
 *      attempts to gain access to the resource. This means, that the token can be sold, traded, or stolen,
 *      and the user will be able to re-use the key once the fingerprint has decayed to
 *      zero. Allowing for normal market activites to occur without the concern of the token
 *      being re-used before you deem acceptable.
 */
contract Fingerprint {
    using PRBMathSD59x18 for int256;

    /// @dev The fingerprint decay rate is the rate at which the fingerprint decays over time.
    int256 public fingerprintDecayRate;

    /// @dev Mapping of fingerprints to their recording time.
    mapping(bytes32 => int256) private fingerprints;

    constructor(
        int256 _fingerprintDecayRate
    ) {
        fingerprintDecayRate = _fingerprintDecayRate;
    }

    /**
     * @notice Enforces that any fingerprint being used to gain access to the resource has decayed to zero
     *         or has not yet been used.
     * @param _fingerprint The fingerprint to check the decay of.
     *
     * Requirements:
     * - The fingerprint must have decayed to zero or not yet been used.
     */
    modifier onlyVirginFingerprints(
        bytes32 _fingerprint
    ) { 
        int256 virginState = fingerprints[_fingerprint] - fingerprintDecayRate;

        require(
              virginState < 1
            , "Fingerprint: Fingerprint already exists");
        _;
    }

    /**
     * @notice Generates a fingerprint for the token and user address without saving it.
     * @param _source The address of the token contract.
     * @param _tokenId The ID of the token.
     * @return fingerprint  The fingerprint for the token address and id.
     */
    function _peakFingerprint(
          address _source
        , uint256 _tokenId
    ) 
        internal
        pure
        returns (
            bytes32 fingerprint
        ) 
    {
        fingerprint = keccak256(abi.encodePacked(
              _source
            , _tokenId
        ));  
    }

    /**
     * @notice Allows the state of the Fingerprint to be updated by implemented the usage
     *         of this function at the time of gaining access.
     * @dev When doing this, one should always set the fingerprint before proceeding with the
     *      effects of having access. (Set the Fingerprint before minting.)
     * @param _fingerprint The fingerprint to be updated.
     */
    function _setFingerprint(
        bytes32 _fingerprint
    ) 
        internal
        onlyVirginFingerprints(_fingerprint)
    {
        fingerprints[_fingerprint] = int256(block.timestamp).toInt();
    }

    /**
     * @notice Returns the fingerprint recording time without any validation checks.
     * @dev This function is not intended to be used by external contracts, and is only 
     *      used internally to determine if the fingerprint has decayed to zero.
     */
    function _getFingerprint(
        bytes32 _fingerprint
    ) 
        internal
        view
        returns (int256)
    {
        return fingerprints[_fingerprint];
    }
    
    /**
     * @notice Allows a user to get the recording time of a fingerprint used for access control.
     * @dev This contract is not meant to be used on-chain and is only meant to be used for external view calls.
     * @param _fingerprint The fingerprint to get the recording time of.
     * @return The recording time of the fingerprint.
     *
     * Requirements:
     * - The fingerprint must already be set.
     */
    function getFingerprint(
        bytes32 _fingerprint
    )
        external
        view
        virtual
        returns (int256)
    {
        require(
              _fingerprint != bytes32(0)
            , "Fingerprint: Fingerprint is empty"
        );

        return _getFingerprint(_fingerprint);
    }
}